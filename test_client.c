/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "test.h"
#include <unistd.h>
#include <stdio.h>
#include <ncurses.h>
#include <stdlib.h>
#include <pthread.h>

#define WIDTH 100
#define HEIGHT_WIN_USR_TEXT 5
#define HEIGHT_WIN_CHAT 30		// constant needs to be the same in the server
#define USERNAME_MAX_LENGTH 23	// 3 extra chars for \0, > and space
#define MESSAGE_MAX_LENGTH 269 	// Limiting user input to 269 per message (nice) twitter style

void destroy_win(WINDOW *local_win);
WINDOW *create_newwin(int height, int width, int starty, int startx);
//void *draw_thread(void * chat_win);

WINDOW *chat_win;
CLIENT *clnt;

void
program_name_1(char *host, char * username)
{
	void  *result_1;
	message  mywrite_1_arg;

#ifndef	DEBUG
	clnt = clnt_create (host, PROGRAM_NAME, ALPHA, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */

	WINDOW *usr_text_win;
	int ch;

	//char msg_buffer[MESSAGE_MAX_LENGTH + USERNAME_MAX_LENGTH];
	char name_buffer[USERNAME_MAX_LENGTH];

	// init to 0 the buffers
	//memset(msg_buffer, MESSAGE_MAX_LENGTH + USERNAME_MAX_LENGTH, 0);
	memset(name_buffer, USERNAME_MAX_LENGTH, 0);

	char * usr_txt = calloc(0,0);
	int num_chars =0;

	//Cut off name at max username length
	if (strlen(username) > (USERNAME_MAX_LENGTH - 3))
	{
		strncpy(name_buffer, username, (USERNAME_MAX_LENGTH - 3));
		name_buffer[(USERNAME_MAX_LENGTH - 3)] = '>';
		name_buffer[(USERNAME_MAX_LENGTH - 2)] = ' ';
		name_buffer[(USERNAME_MAX_LENGTH - 1)] = '\0';
	}else{
		strcpy(name_buffer, username);
		name_buffer[strlen(username)] = '>';
		name_buffer[strlen(username) + 1] = ' ';
		name_buffer[strlen(username) + 2] = '\0';
	}
	
	initscr();			/* Start curses mode 		*/
	cbreak();			/* Line buffering disabled, Pass on
					 	* every thing to me 		*/
	keypad(stdscr, TRUE);		/* I need that nifty F1 	*/
	noecho();
	refresh();

	chat_win = create_newwin(HEIGHT_WIN_CHAT, WIDTH, 0, 0);
	usr_text_win = create_newwin(HEIGHT_WIN_USR_TEXT, WIDTH, HEIGHT_WIN_CHAT, 0);

	wmove(usr_text_win, 1, 1);
	wprintw(usr_text_win, name_buffer);
	wrefresh(usr_text_win);

	// Set up threads
    pthread_t thread;
    pthread_attr_t attr;
    pthread_attr_init(&attr);
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);

    // Spawn the listen/receive deamons
    //pthread_create(&thread, &attr, draw_thread, NULL);

	while((ch = getch()) != KEY_F(1))
	{	
		switch(ch)
		{	case '\n':
				//Finish saving usr input into string
				num_chars++;
				usr_txt = realloc(usr_txt, num_chars * sizeof(char));
				usr_txt[num_chars-1] = '\0';

				//return cursor to beggining usr text window
				werase(usr_text_win);
				box(usr_text_win, 0 , 0);
				wmove(usr_text_win, 1, 1);
				wprintw(usr_text_win, name_buffer);
				wrefresh(usr_text_win);

				// prepare msg to be sent
				char * msg = (char*) malloc((strlen(name_buffer) + strlen(usr_txt)) * sizeof(char));
				strcpy(msg, name_buffer);
				strcat(msg, usr_txt);

				// Send text to server
				mywrite_1_arg.contents = msg;
				result_1 = mywrite_1(&mywrite_1_arg, clnt);
				if (result_1 == (void *) NULL) {
					clnt_perror (clnt, "call failed");
				}

				//reset num chars
				num_chars = 0;
				
				//Print text in chat window
				/*
				werase(chat_win);
				box(chat_win, 0 , 0);
				wmove(chat_win, 1, 1);
				wprintw(chat_win, usr_txt);
				wrefresh(chat_win);
				*/

				message *result_2;
				char *getchar_1_arg;

				result_2 = getchar_1((void*)&getchar_1_arg, clnt);
				if (result_2 == (message *) NULL) {
					//clnt_perror (clnt, "call failed or message empty");
				}else{
					
					werase(chat_win);
					box(chat_win, 0 , 0);
					wmove(chat_win, 1, 1);
					waddstr(chat_win, result_2->contents);
					wrefresh(chat_win);
				}

				break;
			default:
				if(num_chars < MESSAGE_MAX_LENGTH){
					num_chars++;
					usr_txt = realloc(usr_txt, num_chars * sizeof(char));
					usr_txt[num_chars-1] = (char) ch;
					wechochar(usr_text_win, ch);
				}
				break;
		}
	}

	pthread_join(thread, NULL);

	destroy_win(usr_text_win);
	destroy_win(chat_win);
	endwin();
	//return 0;
	
	/*
	mywrite_1_arg.contents = username;
	write(STDOUT_FILENO, mywrite_1_arg.contents, strlen(mywrite_1_arg.contents));

	result_1 = mywrite_1(&mywrite_1_arg, clnt);
	if (result_1 == (void *) NULL) {
		clnt_perror (clnt, "call failed");
	}
	
	result_2 = getchar_1((void*)&getchar_1_arg, clnt);
	if (result_2 == (message *) NULL) {
		clnt_perror (clnt, "call failed");
	}
	*/
#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
}

int
main (int argc, char *argv[]) {
	char *host;
	char *username;

	if (argc < 3) {
		printf ("usage: %s server_host, username\n", argv[0]);
		exit (1);
	}
	
	host = argv[1];
	username = argv[2];

	program_name_1 (host, username);
	exit (0);
}

void destroy_win(WINDOW *local_win)
{	
	/* box(local_win, ' ', ' '); : This won't produce the desired
	 * result of erasing the window. It will leave it's four corners 
	 * and so an ugly remnant of window. 
	 */
	wborder(local_win, ' ', ' ', ' ',' ',' ',' ',' ',' ');
	/* The parameters taken are 
	 * 1. win: the window on which to operate
	 * 2. ls: character to be used for the left side of the window 
	 * 3. rs: character to be used for the right side of the window 
	 * 4. ts: character to be used for the top side of the window 
	 * 5. bs: character to be used for the bottom side of the window 
	 * 6. tl: character to be used for the top left corner of the window 
	 * 7. tr: character to be used for the top right corner of the window 
	 * 8. bl: character to be used for the bottom left corner of the window 
	 * 9. br: character to be used for the bottom right corner of the window
	 */
	wrefresh(local_win);
	delwin(local_win);
}

WINDOW *create_newwin(int height, int width, int starty, int startx)
{	WINDOW *local_win;

	local_win = newwin(height, width, starty, startx);
	box(local_win, 0 , 0);		/* 0, 0 gives default characters 
					 * for the vertical and horizontal
					 * lines			*/
	wrefresh(local_win);		/* Show that box 		*/

	return local_win;
}
/*
void *draw_thread(void * t)
{
	message *result_2;
	char *getchar_1_arg;

	while(1)
	{
		result_2 = getchar_1((void*)&getchar_1_arg, clnt);
		if (result_2 == (message *) NULL) {
			//clnt_perror (clnt, "call failed or message empty");
		}else{
			printf("%s", result_2->contents);
			werase(chat_win);
			box(chat_win, 0 , 0);
			wmove(chat_win, 1, 1);
			wprintw(chat_win, result_2->contents);
			wrefresh(chat_win);
		}
		sleep(1);
	}
}
*/