/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "test.h"
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void *
mywrite_1_svc(message *argp, struct svc_req *rqstp)
{
	static char * result;

	// Open the file and write the message sent

	FILE * file = fopen(FILENAME, "a");

	    for (int i = 0; argp->contents[i] != '\0'; i++) {
            /* write to file using fputc() function */
            fputc(argp->contents[i], file);
        }
		fputc('\n', file);
	fclose(file);

	return (void *) &result;
}

message *
getchar_1_svc(void *argp, struct svc_req *rqstp)
{
	static message result;
	char count =0;
	char line_buffer[MESSAGE_MAX_LENGTH];
	char * file_buffer[10];

	memset(line_buffer, MESSAGE_MAX_LENGTH, 0);

	// Open the file and read the chat log
	FILE * file = fopen(FILENAME, "r");

	fseek(file, 0, SEEK_END);
    long int pos = ftell(file);

    /* Search for '\n' */
    while (pos) {
        fseek(file, --pos, SEEK_SET); /* seek from begin */
		if (fgetc(file) == '\n') {
			if (count++ == 10) break;
		}
    }

	/* Write line by line, is faster than fputc for each char */
	int i=0;
	while (fgets(line_buffer, sizeof(line_buffer), file) != NULL) {
		file_buffer[i] = (char *) malloc(MESSAGE_MAX_LENGTH * sizeof(char));
		memset(file_buffer[i], MESSAGE_MAX_LENGTH, 0);
		
		strcpy(file_buffer[i], line_buffer);
		
		i++;
	}

	// TODO?? If the file is longer than the rows on the screen, 
	// only get last n rows and send those back

	// The client will print everything the server sends back

	fclose(file);

	write(STDOUT_FILENO, file_buffer[0], strlen(file_buffer[0]));
	write(STDOUT_FILENO, "\n", 1);

	result.contents = file_buffer[0];

	return &result;
}
