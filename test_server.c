/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "test.h"
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void *
mywrite_1_svc(message *argp, struct svc_req *rqstp)
{
	static char * result;

	// Open the file and write the message sent

	FILE * file = fopen(FILENAME, "a");

	    for (int i = 0; argp->contents[i] != '\0'; i++) {
            /* write to file using fputc() function */
            fputc(argp->contents[i], file);
        }
		fputc('\n', file);
	fclose(file);

	return (void *) &result;
}

message *
getchar_1_svc(void *argp, struct svc_req *rqstp)
{
	static message result;
	char count =0;
	char line_buffer[MESSAGE_MAX_LENGTH + USERNAME_MAX_LENGTH + 1];
	char file_buffer[HEIGHT_WIN_CHAT][MESSAGE_MAX_LENGTH + USERNAME_MAX_LENGTH + 1];

	memset(line_buffer, 0, MESSAGE_MAX_LENGTH + USERNAME_MAX_LENGTH + 1);

	// Open the file and read the chat log
	FILE * file = fopen(FILENAME, "r");

	if(file != NULL){
		fseek(file, 0, SEEK_END);
		long int pos = ftell(file);

		/* Search for '\n' */
		// If the file is longer than the rows on the screen, 
		// only get last n (HEIGHT_WIN_CHAT) rows
		while (pos > 0) {
			if (fgetc(file) == '\n') {
				if (count++ == HEIGHT_WIN_CHAT) break;
			}
			fseek(file, --pos, SEEK_SET);
		}

		/* Write line by line, is faster than fputc for each char */
		int c=0;
		while (fgets(line_buffer, sizeof(line_buffer), file) != NULL) {			
			strcpy(file_buffer[c], line_buffer);
			c++;
		}

		// The client will print everything the server sends back

		fclose(file);

		// For debugging
		//write(STDOUT_FILENO, file_buffer[0], strlen(file_buffer[0]));

		// Concat all the message into a single variable for sending
		char message_to_send[HEIGHT_WIN_CHAT * (MESSAGE_MAX_LENGTH + USERNAME_MAX_LENGTH + 1)];
		int length = 0;

		for (int i = 0; i < c; i++)
		{
			length += strlen(file_buffer[i]);
			length++;
			//message_to_send = realloc(message_to_send, length * sizeof(char));
			strcat(message_to_send, file_buffer[i]);
		}

		//message_to_send = realloc(message_to_send, length * sizeof(char) + 1);
		message_to_send[length] = '\0';

		result.contents = message_to_send;

		return &result;
	}
	
	// If file could not be opened, doesnt exist or empty
	return NULL;
}
